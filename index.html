<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Таинственный сейф — 3D GOLD</title>
<style>
  :root{
    --bg:#0b1022; --ink:#e9edf7; --muted:#a4abc1;
    --gold1:#fff6c8; --gold2:#ffe08f; --gold3:#ffd05f; --gold4:#f2b941; --gold5:#c08627;
    --cyan:#5ee7ff; --vio:#b8a8ff;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--ink);
    font-family:"Inter","JetBrains Mono",system-ui,monospace;
    background:radial-gradient(1200px 700px at 70% 25%, #1a2361 0, #121a44 40%, var(--bg) 100%);
    overflow-x:hidden;
  }

  #bgfx, #confetti{position:fixed; inset:0; z-index:0; pointer-events:none}
  .scanlines::before{
    content:""; position:fixed; inset:0; z-index:1; pointer-events:none; mix-blend-mode:soft-light;
    background-image:repeating-linear-gradient(0deg, rgba(255,255,255,0.03), rgba(255,255,255,0.03) 1px, transparent 1px, transparent 3px);
    animation: drift 14s linear infinite;
  }
  @keyframes drift{ from{transform:translateY(0)} to{transform:translateY(-8px)} }

  .wrap{min-height:100vh; padding:24px 18px 160px; display:grid; place-items:center; position:relative; z-index:2}
  .hdr{
    text-align:center; letter-spacing:.12em; text-transform:uppercase; font-weight:800; margin-bottom:6px;
    text-shadow:0 0 6px rgba(0,247,255,.55), 0 0 18px rgba(138,125,255,.28);
  }
  .lede{
    max-width:min(980px,95vw);
    margin:0 auto 10px; text-align:center; line-height:1.35; color:var(--muted); font-size:14px;
  }
  .lede strong{color:#fff}
  .lede .rule{display:block; margin-top:4px; color:#ffd768}

  #three{
    width:min(980px,95vw); height:min(620px,70vh);
    border-radius:16px; outline:1px solid rgba(255,255,255,.08);
  }
  .hint{font-size:12px; color:var(--muted); margin-top:6px; text-align:center}

  .code{display:flex; gap:10px; align-items:center; justify-content:center; margin:14px 0; flex-wrap:wrap}
  .digit{
    width:60px; height:66px; text-align:center; font-size:30px; font-weight:800; color:#ffd768;
    background:#0b0e15; border:3px solid #ffd768; border-radius:10px; outline:none; box-shadow:0 8px 20px rgba(255,215,0,.12) inset;
  }
  .btn{
    padding:14px 22px; font-weight:900; letter-spacing:.08em; text-transform:uppercase; border:0; border-radius:12px;
    background:linear-gradient(180deg,var(--gold1),var(--gold2) 35%,var(--gold3) 55%,var(--gold4) 75%,var(--gold5));
    color:#201a00; cursor:pointer; box-shadow:0 12px 24px rgba(255,215,0,.2), 0 0 0 1px rgba(0,0,0,.35) inset;
  }

  .dropzone{width:min(980px,95vw); margin:28px auto 0}
  .grid{display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:18px}
  @media (max-width:760px){ .grid{ grid-template-columns:1fr } }

  .card{
    position:relative; padding:18px 18px 16px 18px; border-radius:14px; overflow:hidden;
    color:#1c1400; box-shadow:
      0 24px 50px rgba(0,0,0,.28),
      0 0 0 1px rgba(0,0,0,.45) inset,
      0 0 0 1px rgba(255,255,255,.06);
    background:
      radial-gradient(120% 120% at 0% 0%, rgba(255,255,255,.16), rgba(255,255,255,0) 50%),
      linear-gradient(180deg,var(--gold1) 0,var(--gold2) 35%,var(--gold3) 55%,var(--gold4) 75%,var(--gold5) 100%);
  }
  .card::after{
    content:""; position:absolute; inset:0; pointer-events:none; opacity:.75;
    background:conic-gradient(from 0deg at 120% -10%, rgba(255,255,255,.25), rgba(255,255,255,0) 60%);
    mix-blend-mode:overlay;
  }
  .card h3{margin:0 0 8px; font-size:20px; display:flex; align-items:center; gap:10px}
  .emoji{
    font-size:22px; width:34px; height:34px; display:grid; place-items:center; border-radius:8px;
    background:rgba(255,255,255,.35); box-shadow:0 0 0 2px rgba(0,0,0,.35) inset;
  }
  .card p{margin:0; color:#3a2a00; line-height:1.35}

  .fly{position:fixed; z-index:6; width:300px; will-change:transform,opacity;
       transform: translate(-50%,-50%) rotate(0deg);
       animation: fall 1.1s cubic-bezier(.2,.9,.2,1) forwards}
  @keyframes fall{
    0%{opacity:0; transform:translate(var(--sx), var(--sy)) rotate(var(--rot))}
    15%{opacity:1}
    100%{opacity:1; transform: translate(var(--ex), var(--ey)) rotate(calc(var(--rot) + 100deg))}
  }

  .alert{padding:10px 14px; background:#ffebe8; color:#7a0b00; border:1px solid #ffb9b0; border-radius:8px; margin:10px 0; font-size:14px}

  /* Стикеры аналитика */
  #stickers{position:fixed; inset:0; pointer-events:none; z-index:9}
  .st{
    position:absolute; left:0; top:0;
    font-size:12px; color:#07141a; background:#e7f8ff;
    border:1px solid #8bd8ff; border-radius:10px; padding:6px 10px; box-shadow:0 6px 18px rgba(0,0,0,.18);
    will-change:transform;
    display:flex; align-items:center; gap:6px; white-space:nowrap;
  }
  .st .e{font-size:16px}
  .st .k{font-family:"JetBrains Mono",monospace; font-weight:700}
</style>
</head>
<body class="scanlines">
<canvas id="bgfx"></canvas>
<div class="wrap">
  <div class="hdr">Таинственный сейф</div>
  <p class="lede">
    Сейф ко дню рождения с мини-событиями.
    <span class="rule">Позже будет <strong>настоящий "золотой" сейф</strong> — его код ты соберёшь по цифрам, которые получишь за выполнение событий ниже (открой сейф).</span>
  </p>
  <div id="three" aria-label="3D сейф"></div>

  <div id="alert" class="alert" style="display:none"></div>

  <div class="code">
    <input class="digit" inputmode="numeric" maxlength="1" pattern="[0-9]*" autofocus>
    <input class="digit" inputmode="numeric" maxlength="1" pattern="[0-9]*">
    <input class="digit" inputmode="numeric" maxlength="1" pattern="[0-9]*">
    <input class="digit" inputmode="numeric" maxlength="1" pattern="[0-9]*">
    <button class="btn" id="openBtn">Открыть</button>
  </div>
  <div class="hint">Крути мышкой (колесо — зум). Код знаешь сама :)</div>

  <section class="dropzone"><div class="grid" id="grid"></div></section>
</div>
<div id="stickers"></div>
<canvas id="confetti"></canvas>

<script src="./three.min.js"></script>
<script src="./OrbitControls.js"></script>

<script>
(function(){
  const show = (msg)=>{ const a=document.getElementById('alert'); a.textContent=msg; a.style.display='block'; };
  if (!window.THREE || !THREE.OrbitControls){ show('Не загрузились three.min.js / OrbitControls.js'); return; }

  /* фон: пыль + спектр + граф */
  const bg = document.getElementById('bgfx');
  const ctx = bg.getContext('2d', { alpha:true });
  ctx.imageSmoothingEnabled = false;
  let t0 = performance.now(); const particles = [], nodes = [];
  function resizeBG(){ bg.width = innerWidth; bg.height = innerHeight; }
  function makeParticles(n=160){
    particles.length = 0;
    for(let i=0;i<n;i++){
      particles.push({ r: Math.random()*Math.hypot(bg.width,bg.height)*0.5 + 40,
        a: Math.random()*Math.PI*2, s: 0.0012 + Math.random()*0.0022,
        x0: bg.width*0.55, y0: bg.height*0.38, w: 1.25 + Math.random()*2.2, hue: 40 + Math.random()*60 });
    }
  }
  function makeNodes(m=34){
    nodes.length=0;
    for(let i=0;i<m;i++){
      nodes.push({ x: bg.width*(0.18+Math.random()*0.64), y: bg.height*(0.16+Math.random()*0.54),
        vx:(Math.random()-.5)*0.35, vy:(Math.random()-.5)*0.35, r: 2.2+Math.random()*2.2 });
    }
  }
  function drawBG(){
    const now = performance.now(); t0 = now;
    ctx.clearRect(0,0,bg.width,bg.height);
    particles.forEach(p=>{
      p.a += p.s;
      const x = p.x0 + Math.cos(p.a)*p.r*0.6;
      const y = p.y0 + Math.sin(p.a)*p.r*0.35;
      ctx.fillStyle = `hsla(${p.hue},95%,65%,.35)`; ctx.beginPath(); ctx.arc(x,y,p.w,0,Math.PI*2); ctx.fill();
    });
    const bars = 90, baseY = bg.height-26, maxH = Math.min(160, bg.height*0.28);
    for(let i=0;i<bars;i++){
      const ph = i*0.25;
      const h = (Math.sin(now*0.004 + ph) + Math.sin(now*0.007 + ph*1.7))*0.5;
      const hh = (0.28 + Math.abs(h))*maxH;
      const x = (bg.width*0.10) + i*((bg.width*0.80)/bars);
      ctx.fillStyle = 'rgba(120,230,255,0.24)'; ctx.fillRect(x, baseY-hh, 6, hh);
      ctx.fillStyle = 'rgba(255,215,120,0.28)'; ctx.fillRect(x+1, baseY-hh*0.7, 4, hh*0.7);
    }
    nodes.forEach(n=>{
      n.x+=n.vx; n.y+=n.vy;
      if(n.x<bg.width*0.16||n.x>bg.width*0.84) n.vx*=-1;
      if(n.y<bg.height*0.14||n.y>bg.height*0.70) n.vy*=-1;
    });
    ctx.save(); ctx.globalCompositeOperation = 'lighter';
    for(let i=0;i<nodes.length;i++){
      for(let j=i+1;j<nodes.length;j++){
        const a=nodes[i], b=nodes[j], d=Math.hypot(a.x-b.x,a.y-b.y);
        if(d<150){
          const alpha = (1-d/150)*0.45;
          ctx.strokeStyle = `rgba(145,200,255,${alpha})`;
          ctx.lineWidth = 1.4; ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
        }
      }
    }
    nodes.forEach(n=>{
      ctx.fillStyle='rgba(255,255,255,0.85)'; ctx.beginPath(); ctx.arc(n.x,n.y,n.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='rgba(88,200,255,0.9)'; ctx.beginPath(); ctx.arc(n.x,n.y,n.r*0.55,0,Math.PI*2); ctx.fill();
    });
    ctx.restore();
    requestAnimationFrame(drawBG);
  }
  resizeBG(); makeParticles(); makeNodes(); drawBG();
  addEventListener('resize', ()=>{ resizeBG(); makeParticles(); makeNodes(); });

  /* сцена */
  const host = document.getElementById('three');
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(35, host.clientWidth/host.clientHeight, 0.1, 200);
  camera.position.set(4.2, 3.1, 6.8);

  const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setSize(host.clientWidth, host.clientHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
  renderer.shadowMap.enabled = true;
  renderer.gammaOutput = true;
  renderer.gammaFactor = 1;
  renderer.toneMapping = THREE.ReinhardToneMapping;
  renderer.toneMappingExposure = 2.6;
  host.appendChild(renderer.domElement);

  const hemi  = new THREE.HemisphereLight(0xffe7b0, 0x202020, .8); scene.add(hemi);
  const key   = new THREE.SpotLight(0xffffff, 1.95, 0, Math.PI/5, .3, 1);
  key.position.set(6,7,6); key.castShadow=true; key.shadow.mapSize.set(1024,1024); scene.add(key);
  const amb   = new THREE.AmbientLight(0xffc676, .35); scene.add(amb);
  const fill  = new THREE.PointLight(0xfff0b0, .9, 10); fill.position.set(-3, 2.2, 3.5); scene.add(fill);
  const rim   = new THREE.PointLight(0x8ac6ff, .7, 10); rim.position.set( 3,-0.2,-3.0); scene.add(rim);

  const ctrl = new THREE.OrbitControls(camera, renderer.domElement);
  ctrl.enableDamping = true; ctrl.enablePan=false; ctrl.minDistance=4; ctrl.maxDistance=12; ctrl.target.set(0,1.6,0);

  const podium = new THREE.Mesh(
    new THREE.CylinderGeometry(4.3,4.6,.22,64),
    new THREE.MeshStandardMaterial({color:0x121724, roughness:.9, metalness:.1})
  );
  podium.receiveShadow=true; podium.position.y=-.11; scene.add(podium);

  const gold      = new THREE.MeshStandardMaterial({ color:0xFFD24A, metalness:.96, roughness:.15, emissive:0x402800, emissiveIntensity:.08 });
  const steelDark = new THREE.MeshStandardMaterial({ color:0x4b5863, metalness:.9,  roughness:.55 });
  const chrome    = new THREE.MeshStandardMaterial({ color:0xdedede, metalness:1.0, roughness:.25 });
  const matteCyan = new THREE.MeshStandardMaterial({ color:0x66e7ff, metalness:.4, roughness:.6, emissive:0x114455, emissiveIntensity:.25 });
  const screenMat = new THREE.MeshBasicMaterial({ color:0xffffff, map:null, transparent:true, opacity:0.96 });

  const safe = new THREE.Group(); scene.add(safe);
  const W=2.9, H=3.3, D=2.6, wall=0.12, frameT=0.12, openW = W*0.72 + 0.12, openH = H*0.78 + 0.12;
  safe.position.y = H/2;

  const parts = new THREE.Group(); safe.add(parts);
  function plate(g, x,y,z){ const m=new THREE.Mesh(g, gold); m.position.set(x,y,z); m.castShadow=m.receiveShadow=true; parts.add(m); }
  plate(new THREE.BoxGeometry(W,H,wall), 0, 0, -D/2+wall/2);
  plate(new THREE.BoxGeometry(wall,H,D), -W/2+wall/2, 0, 0);
  plate(new THREE.BoxGeometry(wall,H,D),  W/2-wall/2, 0, 0);
  plate(new THREE.BoxGeometry(W,wall,D),  0,  H/2-wall/2, 0);
  plate(new THREE.BoxGeometry(W,wall,D),  0, -H/2+wall/2, 0);

  const frame = new THREE.Group(); frame.position.z =  D/2 - frameT/2; safe.add(frame);
  const sideW = (W - openW) / 2;
  function fr(g,x,y){ const m=new THREE.Mesh(g, gold); m.position.set(x,y,0); m.castShadow=m.receiveShadow=true; frame.add(m); }
  fr(new THREE.BoxGeometry(sideW, openH, frameT), -openW/2 - sideW/2, 0);
  fr(new THREE.BoxGeometry(sideW, openH, frameT),  openW/2 + sideW/2, 0);
  fr(new THREE.BoxGeometry(W, (H-openH)/2, frameT), 0,  openH/2 + (H-openH)/4);
  fr(new THREE.BoxGeometry(W, (H-openH)/2, frameT), 0, -openH/2 - (H-openH)/4);

  const footGeo = new THREE.BoxGeometry(.2,.2,.2);
  [[-W/2+.2,-D/2+.2],[W/2-.2,-D/2+.2],[-W/2+.2,D/2-.2],[W/2-.2,D/2-.2]].forEach(([x,z])=>{
    const f=new THREE.Mesh(footGeo,gold); f.position.set(x,-H/2+.1,z); f.castShadow=f.receiveShadow=true; safe.add(f);
  });

  const doorW=W*.9, doorH=H*.85, doorT=.22*D;
  const hinge = new THREE.Group();
  hinge.position.set(-W/2 + wall*1.0, 0,  D/2 - doorT/2);
  safe.add(hinge);

  const door  = new THREE.Mesh(new THREE.BoxGeometry(doorW,doorH,doorT), gold);
  door.position.set(doorW/2, 0, doorT/2);
  door.castShadow=door.receiveShadow=true; hinge.add(door);

  const hgeo = new THREE.BoxGeometry(.12,.24,.24);
  [doorH/2-.34,0,-doorH/2+.34].forEach(y=>{
    const h=new THREE.Mesh(hgeo, steelDark); h.position.set(-doorW/2-.08,y,0); door.add(h);
  });

  const WHEEL_TUNE = { pos:{ x:0.25,y:0.05,z:0.14 }, mountDeg:{ x:90,y:0,z:0 }, coreDeg:{ x:-90,y:0,z:0 } };
  const wheelMount = new THREE.Group();
  wheelMount.position.set(doorW * WHEEL_TUNE.pos.x, doorH * WHEEL_TUNE.pos.y, doorT/2 + WHEEL_TUNE.pos.z);
  wheelMount.rotation.set(THREE.Math.degToRad(WHEEL_TUNE.mountDeg.x),THREE.Math.degToRad(WHEEL_TUNE.mountDeg.y),THREE.Math.degToRad(WHEEL_TUNE.mountDeg.z));
  door.add(wheelMount);

  const wheelVisual = new THREE.Group(); wheelMount.add(wheelVisual);
  const ring = new THREE.Mesh(new THREE.TorusGeometry(0.42, 0.05, 28, 72), chrome); ring.rotation.x = Math.PI/2; wheelVisual.add(ring);
  const wheelCore = new THREE.Group();
  wheelCore.rotation.set(THREE.Math.degToRad(WHEEL_TUNE.coreDeg.x),THREE.Math.degToRad(WHEEL_TUNE.coreDeg.y),THREE.Math.degToRad(WHEEL_TUNE.coreDeg.z));
  wheelVisual.add(wheelCore);
  for (let i=0;i<5;i++){
    const spoke = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.42,18), chrome);
    spoke.rotation.z = i * Math.PI*2/5; wheelCore.add(spoke);
  }
  const hub = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,0.10,32), chrome);
  hub.rotation.x = Math.PI/2; hub.position.z = 0.04; wheelCore.add(hub);

  function makeTextSprite(text, size=256){
    const cvs = document.createElement('canvas'); cvs.width = cvs.height = size;
    const c = cvs.getContext('2d'); const tex = new THREE.CanvasTexture(cvs);
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, color:0xffffff });
    const sp = new THREE.Sprite(mat); const k = 0.35; sp.scale.set(k,k,1);
    sp.userData = { c, tex, size };
    sp.updateLabel = (t)=>{
      const s=size;
      c.clearRect(0,0,s,s);
      c.font = 'bold ' + Math.floor(s*0.55) + 'px JetBrains Mono, monospace';
      c.textAlign='center'; c.textBaseline='middle';
      c.fillStyle='#ffffff'; c.shadowColor='rgba(255,240,180,0.9)'; c.shadowBlur=Math.floor(s*0.06);
      c.fillText(t, s/2, s/2);
      c.globalAlpha=0.18; c.fillStyle='#5ee7ff';
      c.fillRect(0, Math.floor(s*0.28), s, 3);
      c.fillRect(0, Math.floor(s*0.72), s, 2);
      c.globalAlpha=1; tex.needsUpdate = true;
    };
    const ghost = (hex)=>{ const m = new THREE.SpriteMaterial({ map: tex, color: hex, transparent:true, blending:THREE.AdditiveBlending, opacity:0 });
      const g = new THREE.Sprite(m); g.scale.copy(sp.scale); sp.add(g); return g; };
    sp.userData.ghostR = ghost(0xff3355);
    sp.userData.ghostC = ghost(0x55ccff);
    sp.updateLabel(text);
    return sp;
  }

  const timerG = new THREE.Group(); timerG.position.set(0.05, 0.15, -0.20); safe.add(timerG);
  const sprD = makeTextSprite('00'), sprH = makeTextSprite('00'), sprM = makeTextSprite('00'), sprS = makeTextSprite('00');
  const colon1 = makeTextSprite(':'), colon2 = makeTextSprite(':'), colon3 = makeTextSprite(':');
  const gap = 0.25, w=0.26;
  sprD.position.x = - (w*1.5 + gap*1.5);
  colon1.position.x = - (w*0.5 + gap*1.0);
  sprH.position.x = - (w*0.0 + gap*0.5);
  colon2.position.x =   (w*0.5 + gap*0.0);
  sprM.position.x =     (w*1.0 + gap*0.5);
  colon3.position.x =   (w*1.5 + gap*1.0);
  sprS.position.x =     (w*2.0 + gap*1.5);
  [sprD, sprH, sprM, sprS, colon1, colon2, colon3].forEach(s=>{ s.position.y=0; timerG.add(s); });

  function startCountdown(){
    const now=new Date();
    const year=(now.getMonth()>10 || (now.getMonth()===10 && now.getDate()>12)) ? now.getFullYear()+1 : now.getFullYear();
    const target=new Date(year,10,12,0,0,0);
    const pad=n=>('0'+n).slice(-2);
    (function tick(){
      const t=new Date(); let diff=Math.max(0, target - t);
      const d=Math.floor(diff/86400000); diff%=86400000;
      const h=Math.floor(diff/3600000);  diff%=3600000;
      const m=Math.floor(diff/60000);    diff%=60000;
      const s=Math.floor(diff/1000);
      sprD.updateLabel(pad(d)); sprH.updateLabel(pad(h)); sprM.updateLabel(pad(m)); sprS.updateLabel(pad(s));
      requestAnimationFrame(tick);
    })();
  }
  startCountdown();

  let glitchPower = 0;
  setInterval(()=>{ glitchPower = Math.random() < 0.8 ? (0.35 + Math.random()*0.9) : 0; }, 380);
  function applyGlitch(sprite){
    const gp = glitchPower, r = sprite.userData.ghostR, c = sprite.userData.ghostC;
    if(!r || !c) return;
    r.material.opacity = gp*0.95; c.material.opacity = gp*0.85;
    const off = (v)=> (Math.random()*2-1)*v*gp;
    r.position.set(off(0.04), off(0.04), 0);
    c.position.set(off(0.04), off(0.04), 0);
    sprite.material.rotation = (Math.random()*2-1) * gp * 0.22;
    const base=0.56, amp=0.12, scale=base + Math.sin(performance.now()*0.012 + off(1))*amp;
    sprite.scale.set(scale, scale, 1);
    r.scale.copy(sprite.scale); c.scale.copy(sprite.scale);
  }

  const cakeG = new THREE.Group(), hatG  = new THREE.Group(); safe.add(cakeG, hatG);
  const cakeBase = new THREE.Mesh(new THREE.CylinderGeometry(0.55,0.55,0.24,32), new THREE.MeshStandardMaterial({color:0x8b4513, metalness:.2, roughness:.8}));
  const cakeTop  = new THREE.Mesh(new THREE.CylinderGeometry(0.52,0.52,0.10,32), new THREE.MeshStandardMaterial({color:0xffe3f1, metalness:.1, roughness:.4}));
  cakeTop.position.y = 0.17; cakeG.add(cakeBase, cakeTop);
  for (let i=0;i<3;i++){
    const cx = -0.18 + i*0.18;
    const candle = new THREE.Mesh(new THREE.CylinderGeometry(0.022,0.022,0.18,12), new THREE.MeshStandardMaterial({color:0xffffff, roughness:.6, metalness:.1}));
    candle.position.set(cx, 0.30, 0);
    const flame  = new THREE.Mesh(new THREE.SphereGeometry(0.03, 12, 12), new THREE.MeshStandardMaterial({color:0xffd05a, emissive:0xffc247, emissiveIntensity:1.2, roughness:.2, metalness:.2}));
    flame.position.set(cx, 0.40, 0);
    cakeG.add(candle, flame);
  }
  (function placeCake(){
    const cakeHeight = 0.34;
    const floorY = -H/2 + wall + cakeHeight/2;
    cakeG.position.set(0, floorY, -0.38);
    cakeG.scale.setScalar(1);
  })();
  (function buildHat(){
    const size=256, cvs=document.createElement('canvas'); cvs.width=cvs.height=size; const c=cvs.getContext('2d');
    c.fillStyle='#6a5df2'; c.fillRect(0,0,size,size);
    for(let i=0;i<6;i++){ c.fillStyle = `hsl(${i*60},95%,70%)`; c.fillRect(0, i*40+10, size, 12); }
    const tex=new THREE.CanvasTexture(cvs);
    const hat = new THREE.Mesh(new THREE.ConeGeometry(0.28,0.52,40), new THREE.MeshStandardMaterial({map:tex, roughness:.5, metalness:.2}));
    const pom = new THREE.Mesh(new THREE.SphereGeometry(0.05,16,16), new THREE.MeshStandardMaterial({color:0xffffff, roughness:.3, metalness:.2}));
    const hatCore = new THREE.Group(); hatCore.add(hat, pom); hat.position.set(0, -1.2, 0.2); pom.position.set(0, -0.9, 0.2);
    hatG.add(hatCore); hatG.position.set(0.65, -0.05, 0.0); hatG.scale.setScalar(1);
  })();

  const studio = new THREE.Group(); safe.add(studio);
  (function(){
    const stand = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,1.0,16), steelDark); stand.position.set(-0.6, -1, 0.2); stand.castShadow=stand.receiveShadow=true;
    const foot = new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.18,0.05,24), steelDark); foot.position.set(-0.6, -1.5, 0.2);
    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,0.2,20), matteCyan); body.position.set(-0.6, -0.8, 0.2);
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.09, 22, 22), new THREE.MeshStandardMaterial({color:0xdddddd, metalness:.6, roughness:.35, emissive:0x2aa9c9, emissiveIntensity:.35}));
    head.position.set(-0.6, -0.5, 0.2);
    studio.add(stand,foot,body,head);
  })();

  const headphones = new THREE.Group(), headArcG = new THREE.Group(), leftEarG = new THREE.Group(), rightEarG = new THREE.Group();
  (function(){
    headphones.position.set(-0.6, -1, 0.22);
    leftEarG.position.set(-0.35,-0.1,0); rightEarG.position.set(0.35,-0.1,0);
    const arc = new THREE.Mesh(new THREE.TorusGeometry(0.35,0.06,16,128,Math.PI*1), chrome);
    arc.rotation.z=Math.PI/2; headArcG.add(arc);
    function makeEar(){
      const g = new THREE.Group();
      const cup = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,0.18,24), steelDark); cup.rotation.x=Math.PI/2;
      const pad = new THREE.Mesh(new THREE.TorusGeometry(0.12,0.03,12,24), steelDark); pad.rotation.x=Math.PI/2;
      g.add(cup,pad); return g;
    }
    leftEarG.add(makeEar()); rightEarG.add(makeEar());
    headphones.add(headArcG, leftEarG, rightEarG); studio.add(headphones);
  })();

  const deg = THREE.Math.degToRad;
  const ARC_ROT_DEG = { x: 0, y: 0, z: -90 };
  const EAR_YAW_DEG = 12;
  function applyArcAndEars(){
    headArcG.rotation.set(deg(ARC_ROT_DEG.x), deg(ARC_ROT_DEG.y), deg(ARC_ROT_DEG.z));
    leftEarG.rotation.y = deg(EAR_YAW_DEG); rightEarG.rotation.y = -deg(EAR_YAW_DEG);
  }
  applyArcAndEars();
  window.setArcDeg = (x=0,y=0,z=0)=>{ ARC_ROT_DEG.x=x; ARC_ROT_DEG.y=y; ARC_ROT_DEG.z=z; applyArcAndEars(); };
  window.setEarYaw = (d=0)=>{ leftEarG.rotation.y=deg(d); rightEarG.rotation.y=deg(-d); };

  const screenPlane = new THREE.Mesh(new THREE.PlaneGeometry(2.8, 1.6), screenMat);
  screenPlane.position.set(0, 0, -D/2 + 0.2); studio.add(screenPlane);
  (function makeScreen(){
    const s=256, cvs=document.createElement('canvas'); cvs.width=cvs.height=s; const c=cvs.getContext('2d');
    c.imageSmoothingEnabled=false; screenMat.map=new THREE.CanvasTexture(cvs); screenMat.map.needsUpdate=true;
    (function paint(t){
      c.clearRect(0,0,s,s); c.fillStyle='#030a0c'; c.fillRect(0,0,s,s);
      c.font='bold 20px JetBrains Mono, monospace'; c.fillStyle='#66e7ff';
      for(let y=20;y<s;y+=22){ for(let x=12;x<s;x+=16){ if(Math.random()>0.55) c.fillText(Math.random()<0.5?'0':'1', x, y); } }
      c.fillStyle='rgba(255,255,255,0.09)'; c.fillRect(0,(t/8)%s,s,3);
      screenMat.map.needsUpdate=true; requestAnimationFrame(paint);
    })(0);
  })();

  /* стикеры аналитика — 7 штук, упругие прыжки */
  const stickers = [
    {e:'📊', k:'UML → 🎉'},
    {e:'🧠', k:'ETL → Cake'},
    {e:'🧩', k:'Regex', v:'/^(party)+$/i'},
    {e:'🗄️', k:'SQL',  v:'SELECT * FROM surprises;'},
    {e:'📦', k:'JSON', v:'{"wow":true}'},
    {e:'🧾', k:'Task', v:'#JIRA-BIRTHDAY'},
    {e:'🔗', k:'Graph',v:'nodes ⇄ edges'}
  ];
  const stWrap = document.getElementById('stickers'); const stObjs = [];
  const groundY = () => innerHeight - 35; const L = 90;
  function spawnStickers(){
    const pool = stickers.slice();
    for (let i = pool.length - 1; i > 0; i--){ const j = Math.floor(Math.random() * (i + 1)); [pool[i], pool[j]] = [pool[j], pool[i]]; }
    const n = 7;
    for(let i=0;i<n;i++){
      const data = pool[i];
      const el = document.createElement('div'); el.className='st';
      el.style.left='0px'; el.style.top='0px';
      el.innerHTML = `<span class="e">${data.e}</span><span class="k">${data.k}</span>${data.v?`<span class="k"> ${data.v}</span>`:''}`;
      stWrap.appendChild(el);
      const obj = {
        el,
        x: innerWidth*(0.15+Math.random()*0.7),
        y: groundY(),
        vx:(Math.random()*2+1)*(Math.random()<.5?-1:1),
        vy:-(2+Math.random()*2),
        g: 0.22+Math.random()*0.05,
        nextHop: performance.now() + 800 + Math.random()*2200
      };
      stObjs.push(obj);
      el.style.transform = `translate(${obj.x}px, ${obj.y}px)`;
    }
  }
  function tickStickers(){
    const now = performance.now();
    stObjs.forEach(s=>{
      s.vy += s.g;
      s.x  += s.vx; s.y += s.vy;
      if(s.x < L){ s.x = L; s.vx *= -0.9; }
      if(s.x > innerWidth - L){ s.x = innerWidth - L; s.vx *= -0.9; }
      if(s.y > groundY()){
        s.y = groundY(); s.vy *= -0.68; s.vx *= 0.96; if(Math.abs(s.vy) < 0.35) s.vy = 0;
      }
      if(s.y >= groundY() && now >= s.nextHop){
        s.vy = -(3.2 + Math.random()*15); s.vx += (Math.random()*0.8 - 0.4);
        s.nextHop = now + 1500 + Math.random()*2000;
      }
      if(s.y < groundY()){ s.vx *= 0.995; s.vy *= 0.995; }
      s.el.style.transform = `translate(${s.x}px, ${s.y}px)`;
    });
    requestAnimationFrame(tickStickers);
  }
  spawnStickers(); tickStickers();
  addEventListener('resize', ()=>{ stObjs.length=0; stWrap.innerHTML=''; spawnStickers(); });

  /* цикл рендера, глитч таймера и открытие сейфа */
  let opening=false, openProgress=0;
  (function anim(){ requestAnimationFrame(anim);
    if(opening && openProgress<1){
      openProgress = Math.min(1, openProgress+.012);
      hinge.rotation.y = -THREE.Math.degToRad(110) * openProgress;
    }
    [sprD, sprH, sprM, sprS, colon1, colon2, colon3].forEach(applyGlitch);
    ctrl.update(); renderer.render(scene,camera);
  })();

  const inputs=[...document.querySelectorAll('.digit')];
  inputs.forEach((el,i)=>{
    el.addEventListener('input',e=>{
      e.target.value=e.target.value.replace(/\D/g,'').slice(-1);
      if(e.target.value && i<inputs.length-1) inputs[i+1].focus();
    });
    el.addEventListener('keydown',e=>{
      if(e.key==='Backspace' && !el.value && i>0) inputs[i-1].focus();
      if(e.key==='Enter') openSafe();
    });
  });
  document.getElementById('openBtn').addEventListener('click', openSafe);
  addEventListener('keydown',e=>{ if(e.key==='Enter') openSafe(); });

  function openSafe(){
  if(opening) return;
  const entered = inputs.map(i=>i.value).join('');
  if(entered !== "1211"){
    show("❌ Неверный код, попробуй снова");
    return;
  }
  opening = true;
  shootConfetti();
  setTimeout(()=>{ dropEvents(); show('О боже — это таймер до твоего дня рождения! 🎂'); }, 350);
}

  const conf=document.getElementById('confetti'), k=conf.getContext('2d'); k.imageSmoothingEnabled=false;
  function shootConfetti(){
    conf.width=innerWidth; conf.height=innerHeight;
    const pieces=Array.from({length:260},()=>({
      x:innerWidth*.55+(Math.random()*140-70), y:innerHeight*.42+(Math.random()*30-15),
      vx:(Math.random()*4-2), vy:-(Math.random()*6+6), w:6+Math.random()*7, h:8+Math.random()*12,
      rot:Math.random()*Math.PI, vr:(Math.random()-.5)*.3, col:'hsl('+Math.floor(Math.random()*360)+',90%,60%)'
    }));
    (function step(){
      k.clearRect(0,0,conf.width,conf.height); let alive=false;
      pieces.forEach(p=>{
        p.vy+=.25; p.x+=p.vx; p.y+=p.vy; p.rot+=p.vr; if(p.y<innerHeight+40) alive=true;
        k.save(); k.translate(p.x,p.y); k.rotate(p.rot); k.fillStyle=p.col; k.fillRect(-p.w/2,-p.h/2,p.w,p.h); k.restore();
      });
      if(alive) requestAnimationFrame(step); else k.clearRect(0,0,conf.width,conf.height);
    })();
  }

  const grid=document.getElementById('grid');
  function dropEvents(){
    const events=[
      {emoji:'🎮', t:'Событие 1', d:'Мини-игра на телефон (эксклюзив для тебя!)'},
      {emoji:'🎭', t:'Событие 2', d:'Иммерсивное шоу :)'},
      {emoji:'🕵️', t:'Событие 3', d:'Секретный экспириенс — детали позже'},
      {emoji:'✨', t:'Событие 4', d:'Сюрприз — придумаю и скажу в моменте'}
    ];
    const startX=innerWidth*.52, startY=innerHeight*.38, baseY=Math.min(innerHeight-120,startY+260);
    events.forEach((ev,idx)=>{
      const temp=document.createElement('div'); temp.className='card fly';
      temp.innerHTML=`<h3><span class="emoji">${ev.emoji}</span>${ev.t}</h3><p>${ev.d}</p>`; document.body.appendChild(temp);
      const ex=innerWidth*.28+Math.random()*innerWidth*.44, ey=baseY+Math.random()*70+idx*16;
      temp.style.setProperty('--sx',startX+'px'); temp.style.setProperty('--sy',startY+'px');
      temp.style.setProperty('--ex',ex+'px');     temp.style.setProperty('--ey',ey+'px');
      temp.style.setProperty('--rot',(Math.random()*60-30)+'deg');
      temp.addEventListener('animationend',()=>{
        const card=document.createElement('div'); card.className='card';
        card.innerHTML=`<h3><span class="emoji">${ev.emoji}</span>${ev.t}</h3><p>${ev.d}</p>`;
        grid.appendChild(card); temp.remove();
      });
    });
  }
})();
</script>
</body>
</html>
